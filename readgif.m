function [IMGs,D]=readgif(fnaam,bOnlyData,bCreateImgs)%readgif - Reads a GIF-graphics file%     [IMGs,D]=readgif(fnaam)% see http://www.matthewflickinger.com/lab/whatsinagif/bits_and_bytes.aspnMaxRead=1e7;if nargin<2||isempty(bOnlyData)	bOnlyData=false;endif nargin<3||isempty(bCreateImgs)	bCreateImgs=true;endif isa(fnaam,'uint8')	x=fnaam;	if size(x,1)>1&&size(x,2)==1		x=x';	endelse	fid=fopen(fnaam);	if fid<3		error('Can''t open file.')	end	x=fread(fid,[1,nMaxRead],'*uint8');	fclose(fid);endif ~strcmp(char(x(1:3)),'GIF')	error('Not a GIF-file')endGIFver=char(x(4:6));switch GIFvercase '87a'	gVer=1;case '89a'	gVer=2;otherwise	error('Unknown gif-version')endendian=[1;256];W=double(x(7:8))*endian;H=double(x(9:10))*endian;packed=x(11);bgColor=x(12);aRatio=x(13);szGCTable=rem(double(packed),8);CTsort=bitand(packed,8)>0;Cresol=bitand(packed,112)/16+1;GCTflag=packed>127;iX=14;if GCTflag	[gCOLs,iX]=GetColorTable(x,iX,szGCTable);else	gCOLs=zeros(0,3);endGCExt=[];IMGs=[];while true	% run through	if iX>length(x)		warning('?!End without trailer?!')		break	end	bID=x(iX);	switch bID		case 33	% extension			extID=x(iX+1);			[extBlocks,iX]=GetBlocks(x,iX+2);			switch extID				case 249	% graphics control extension					if length(extBlocks)~=1||length(extBlocks{1})~=4						warning('GCE expected to contain 1 subblock of 4 bytes!')					end					F=double(extBlocks{1}(1));					TCflag=rem(F,2)>0;					UIflag=rem(F,4)>1;					DisposalM=rem(floor(F/4),8);					delTime=double(extBlocks{1}(2:3))*endian;					transColIdx=extBlocks{1}(4);					GCExt=var2struct(TCflag,UIflag,DisposalM,delTime,transColIdx);				case 1	% plain text extension				case 255	% application extension				case 254	% comment extension				otherwise					error('Error in graphic control extension! (%02x)',x(iX+1))			end		case 44	% image descriptor			pos=endian'*double(reshape(x(iX+1:iX+8),2,4));			F=double(x(iX+9));			szLcol=rem(double(F),8);			sortF=bitand(F,32)>0;			intFlag=bitand(F,64)>0;			locColFlag=F>127;			imDesc=var2struct(pos,szLcol,sortF,intFlag,locColFlag);			iX=iX+10;			if locColFlag				[COLs,iX]=GetColorTable(x,iX,szLcol);				sz=szLcol;			else				COLs=gCOLs;				sz=szGCTable;			end			% read image data			LZWmin=x(iX);			[Bimg,iX]=GetBlocks(x,iX+1);			Bimg=[Bimg{:}];			if bOnlyData				Y=[];			else				[Y,bOK]=LZWDecomp(Bimg,sz,LZWmin,pos(3)*pos(4));				if bOK					Y=reshape(Y,pos(3),pos(4))';				end			end			img=struct('imDesc',imDesc,'COLs',COLs,'LZWmin',LZWmin	...				,'Bimg',Bimg,'img',Y);			if isempty(IMGs)				IMGs=img;			else				IMGs(1,end+1)=img; %#ok<AGROW>			end		case 59	% trailer			if iX<length(x)				warning('Data after the end of the GIF?')			end			break		otherwise			error('Unknown block type!')	end		% switch bIDend		% run through fileif bCreateImgs&&length(IMGs)>1	X=IMGs(1).img;	for i=1:length(IMGs)		P=IMGs(i).imDesc.pos;		I=IMGs(i).img;		if GCExt.TCflag&&any(I(:)==GCExt.transColIdx)			I0=X(P(2)+1:P(2)+P(4),P(1)+1:P(1)+P(3));			I(I==255)=I0(I==255);		end		X(P(2)+1:P(2)+P(4),P(1)+1:P(1)+P(3))=I;		IMGs(i).imgFull=X;	endendif nargout>1	D=struct('gVer',gVer,'version',GIFver,'W',W,'H',H	...		,'bgColor',bgColor,'aRatio',aRatio	...		,'szGCTable',szGCTable,'CTsort',CTsort,'Cresol',Cresol,'GCTflag',GCTflag	...		,'gCOLs',gCOLs,'GCExt',GCExt);endfunction [COLs,iX]=GetColorTable(x,iX,sz)nCol=2^(sz+1);COLs=uint8(reshape(x(iX:iX+nCol*3-1),3,nCol))';iX=iX+3*nCol;function [B,iX]=GetBlocks(x,iX)BB=cell(1,1000);	% reserve space for blocksnB=0;while x(iX)	nB=nB+1;	iN=iX+double(x(iX));	BB{nB}=x(iX+1:iN);	iX=iN+1;endiX=iX+1;B=BB(1:nB);function [Y,bOK]=LZWDecomp(X,nC,LZWmin,nEl)T=cell(1,4095);	% first element is not included (colour 0)B=false(1,4095);CCode=2^(double(nC)+1);EOI=CCode+1;for		i=1:CCode-1		% niet nodig (en niet gebruikt)	T{i}=i;endB(1:EOI)=true;nT=EOI;nTn=CCode*2-1;codeSize=double(LZWmin)+1;iX=1;iB=0;[code,iX,iB]=getbits(X,iX,iB,codeSize,true);if code~=CCode	error('Code not starting with Clear Code?!')end[code,iX,iB]=getbits(X,iX,iB,codeSize,true);Y=zeros(1,nEl,'uint8');nY=1;Y(1)=code;old=code;bOK=true;while iX<=length(X)	% should always be true - since an EOI is used	[code,iX,iB]=getbits(X,iX,iB,codeSize,true);	if code==EOI		break;	% THE END	elseif code==CCode		nT=EOI;		B(EOI+1:end)=false;		codeSize=double(LZWmin)+1;		nTn=CCode*2-1;		[code,iX,iB]=getbits(X,iX,iB,codeSize,true);		if code==EOI			%strange..., a CCode just before an EOI!			break;		end		nY=nY+1;		Y(nY)=code;		old=code;		% nog iets?	else	% normal code		if old<EOI			C=old;		else			C=T{old};		end		if code<EOI||B(code)	% CODE in code table			if code<EOI		% not possible (?)				KK=code;			else				KK=T{code};			end			Y(nY+1:nY+length(KK))=KK;			nY=nY+length(KK);			K=KK(1);		else			Y(nY+1:nY+length(C))=C;			nY=nY+length(C)+1;			K=C(1);			Y(nY)=K;		end		nT=nT+1;		if nT<=nTn			T{nT}=[C K];			B(nT)=true;		end		if nT>=nTn&&codeSize<12			nTn=nTn*2+1;			codeSize=codeSize+1;		end		old=code;	endend		% whileif nY~=nEl	warning('Different number of elements after compression than expected?!')	if nY<nEl		Y=Y(1:nY);	end	bOK=false;end