function D=fitsineVF(t,x,fStart,fEnd,varargin)%fitsineVF  - Fit sine with varying frequency through a number of points%    D=fitsineVF(t,x,fStart,fEnd[,options])%   Fits a sine wave through a signal from which it is expected to be close%   to a sine wave with a linearly varying known frequency.%   It is not necessary to have equidistant points.%  possible options : (pairs of option name and value)%     The estimated DC component, amplitude, time offset are updated%        successively by a cpu intensive, simple algorithm.  The error%        value (between the calculated sine and (unfiltered) signal is%        calculated for a couple of values.  A 2nd order polynomial is%        fitted, and the minimum value is used, if this is between%        estimated limits.% The function can also be used to calculate values using the%    fitsine-output:%        y=fitsine(D,t);%  t can be time vector, but also dt%%  see also StonHann (much faster function without fitting with often%                     better results!!!)% also possible:%    fitsine warnings (or fitsine w)%        give warnings (default)%    fitsine nowarnings (or sitsine n)%        don't give warnings (some "real warnings" are still given)persistent doWarningsif isempty(doWarnings)	doWarnings=true;endoptions=varargin;if ischar(t)	if lower(t(1))=='w'		doWarnings=true;	elseif lower(t(1))=='n'		doWarnings=false;	else		error('wrong use of this function')	end	returnelseif isstruct(t)	%!!!update	D=cos((x-t.toffset)*(t.f*2*pi))*t.A+t.DC;	returnelseif min(size(t))>1	if nargin>1&&isnumeric(x)		error('Something is wrong with inputs')	end	if ~isempty(varargin)		options=[{x},varargin];	end	if size(t,1)<size(t,2)		t=t';	end	x=t(:,2);	t=t(:,1);endwStart=fStart*2*pi;wEnd=fEnd*2*pi;if isscalar(t)	dt=t;	tEnd=(length(x)-1)*dt;	t=(0:length(x)-1)'*dt;	dW=(wEnd-wStart)/tEnd;	wPh=t*wStart+dW/2*t.^2;else	tStart=min(t);	% t may be given in random order(!?)	tEnd=max(t);	dW=(wEnd-wStart)/(tEnd-tStart);	wPh=(t-tStart)*wStart+dW/2*(t-tStart).^2;endnLoop=4;rLimE=1e-8;bTest=false;if ~isempty(options)	setoptions({'nLoop','bTest','rLimE'},options{:})enddf=0;nPts=length(t);DC=mean(x);Zx=sum((x-DC).*sin(wPh));Zy=sum((x-DC).*cos(wPh));A=sqrt(Zx*Zx+Zy*Zy)/(nPts/2);phase=-atan2(Zx,Zy);dA=A/10;dDC=dA;dOffset=pi/5;xf=x;mnDif=[];meanT=[];delT=[];E=[];y=cos(wPh+phase)*A+DC;e0=sqrt(mean((x-y).^2));limE=A*rLimE;e01=e0;relList=-1.5:0.3:1.5;if bTest	if isempty(fSet) %#ok<UNRCH>		TTT=struct('T','freq dt A DC','P',zeros(4,3)	...			,'Elijst',zeros(4,length(relList))	...			,'E',zeros(4,3));		i_F=1;i_dt=2;i_A=3;i_DC=4;	else		TTT=struct('T','dt A DC','P',zeros(3,3)	...			,'Elijst',zeros(3,length(relList))	...			,'E',zeros(3,3));		i_dt=1;i_A=2;i_DC=3;	endend% Do small corrections (in a too calculation intensive way)for iLoop=1:nLoop	dt=relList*dOffset;	eLijst=dt;	for i=1:length(dt)		y1=cos(wPh+phase+dt(i))*A+DC;		eLijst(i)=sum((x-y1).^2);	end	[p,~,Mu]=polyfit(dt,eLijst,2);	dtMin=-p(2)/(2*p(1))*Mu(2)+Mu(1);	if bTest		TTT.P(i_dt,:)=p; %#ok<UNRCH>		TTT.Elijst(i_dt,:)=eLijst;		TTT.E(i_dt,:)=[min(eLijst) phase dOffset];		subplot 222		plot(dt,[eLijst;polyval(p,(dt-Mu(1))/Mu(2))]');grid		title dt		line([0 0]+dtMin,[min(eLijst) max(eLijst)],'color',[1 0 0])		xlabel(sprintf('%10.6f - %10.6f (%10.6f)',phase,dtMin,dOffset))	end	if abs(dtMin)>dt(end);		if doWarnings			warning('FITSINE:DToffsetHigh','dt-offset was too big to be done (%g <--> %g s)!!',dtMin,dOffset)		end		[~,i]=min(eLijst);		dtMin=dt(i);	else		dOffset=dOffset/3;	end	y1=cos(wPh+phase+dtMin)*A+DC;	e01=sqrt(mean((x-y1).^2));	if e01>=e0		if abs(e0-e01)/e0>1e-4&&e0>limE&&abs(dtMin)/dOffset>0.2			if doWarnings				warning('FITSINE:NoImprovementForToffset','!!no improvement!!')			end		end	else		phase=phase+dtMin;		e0=e01;		y(:)=y1;		if e0<limE			break;	% good enough!		end	end		DA=relList*dA;	eLijst=dA;	for i=1:length(DA)		y1=cos(wPh+phase)*(A+DA(i))+DC;		eLijst(i)=sum((x-y1).^2);	end	[p,~,Mu]=polyfit(DA,eLijst,2);	dAMin=-p(2)/(2*p(1))*Mu(2)+Mu(1);	if bTest		TTT.P(i_A,:)=p; %#ok<UNRCH>		TTT.Elijst(i_A,:)=eLijst;		TTT.E(i_A,:)=[min(eLijst) A dA];		subplot 223		plot(DA,[eLijst;polyval(p,(DA-Mu(1))/Mu(2))]');grid		title Amplitude		line([0 0]+dAMin,[min(eLijst) max(eLijst)],'color',[1 0 0])		xlabel(sprintf('%10.5f - %10.5f (%10.5f)',A,dAMin,dA))	end	if abs(dAMin)>DA(end);		if doWarnings			warning('FITSINE:AoffsetTooBig','A-offset was too big to be done (%g <--> %g)!!',dAMin,dA)		end		[~,i]=min(eLijst);		dAMin=DA(i);	else		dA=dA/3;	end	y1=cos(wPh+phase)*(A+dAMin)+DC;	e01=sqrt(mean((x-y1).^2));	if e01>=e0		if abs(e0-e01)/e0>1e-4&&abs(dAMin)/dA>0.2			if doWarnings				warning('FITSINE:NoImprovementWithAcor','!!no improvement!!')			end		end	else		A=A+dAMin;		e0=e01;		y(:)=y1;		if e0<limE			break;	% good enough!		end	end		DClijst=relList*dDC;	eLijst=DClijst;	for i=1:length(DClijst)		y1=cos(wPh+phase)*A+(DC+DClijst(i));		eLijst(i)=sum((x-y1).^2);	end	[p,~,Mu]=polyfit(DClijst,eLijst,2);	DCMin=-p(2)/(2*p(1))*Mu(2)+Mu(1);	if bTest		TTT.P(i_DC,:)=p; %#ok<UNRCH>		TTT.Elijst(i_DC,:)=eLijst;		TTT.E(i_DC,:)=[min(eLijst) DC dDC];		TTT.E(:,1)=sqrt(TTT.E(:,1)/length(x));		printmat([TTT.P TTT.E]	...			,sprintf('iteration %d (%g)',iLoop,111)	...			,TTT.T,'p2 p1 p0 E V del')		subplot 224		plot(DClijst,[eLijst;polyval(p,(DClijst-Mu(1))/Mu(2))]');grid		title DCoffset		line([0 0]+DCMin,[min(eLijst) max(eLijst)],'color',[1 0 0])		xlabel(sprintf('%10.6f - %10.6f (%10.6f)',DC,DCMin,dDC))	end	if abs(DCMin)>DClijst(end);		if doWarnings			warning('FITSINE:DCoffetTooBig','DC-offset was too big to be done (%g <--> %g)!!',DCMin,dDC)		end		[~,i]=min(eLijst);		DCMin=DA(i);	else		dDC=dDC/3;	end	y1=cos(wPh+phase)*A+(DC+DCMin);	e01=sqrt(mean((x-y1).^2));	if e01>=e0		if abs(e0-e01)/e0>1e-4&&abs(DCMin)/dDC>0.2			if doWarnings				warning('FITSINE:NoImprovementWithDC','!!no improvement!!')			end		end	else		DC=DC+DCMin;		e0=e01;		y(:)=y1;		if e0<limE			break;	% good enough!		end	endendD=struct('t',t,'x',x,'xf',xf	...	,'A',A,'dA',dA,'P',mnDif,'P_est2',meanT,'dP',delT	...	,'f',[fStart,fEnd]	...	,'DC',DC,'dDC',dDC,'dtoffset',dOffset	...	,'phase',phase	...	,'E',E	...	,'y',y,'e0',e0,'e1',e01	...	);