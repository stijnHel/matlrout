function [out,optsUsed,notUsed,options,varargout]=setoptions(varargin)%setoptions - Set options in calling variable workspace%   setoptions({<posoptions>},{options})% or%   setoptions({<posoptions>},options) (options given as separate arguments)%    {<posoptions>} : a list of names for possible options%    options : a list of pairs of option-names and values%           {'name-option1',<value-option1>,'name-option2'....}%           it's also allowed to have:%                  {'name-option1','name-option2',...;%                   <value-option2>,....}%           if more than 2 options are given, it is allowed to have:%              {'name-option1',<value-option1;'name-option2'....}%           options starting with '-' (e.g. -Option) sets option to true%                   starting with '--' sets option to false%                   starting with '---' "special on" sets option to -1%                   with '=' (e.g. Option=15) is the same as 'Option',15% alternative use:%   out=setoptions({<posoptions>},{options});%      puts the options in a structure%        to start with a default structure, use the following first option%            'structBase' (full word!),starting structure%           or (newer) use%           out=setoptions({<posoptions},<structBase>,<options>);%           or%           out=setoptions(<structBase>,<options>);%                    (all fieldnames are possible options)% an additional output is available that gives what options are used:%     logical vector with true on the position of the used options% to hide options that are not used, do:%    [[out,optsUsed]=]setoptions(2,{...}...);%          the first value, if it is numeric is interpreted as:%             0 : give an error if option is unknown%             1 : give an warning if option is unknown%             2 : just continue if option is unknown%    to be able to check which options are used, and still set options%    in variables of the caller's workspace, the used of this (first%    numeric input) is expanded:%    [[out,optsUsed]=]setoptions([2,0],{...}...);%            the second number means :%                0: variable assignment%                1: struct-output%                2: variable assignment + variable output% examples:%   setoptions({'abc','def'},'abc',0)%% Option names are used as case-insensitive, except when multiple% possibilities exist.  Names can also be abbreviated, as long as the% separate options can be distinguished well.% Stijn Helsen 2006bStructOut=nargout>0;bDefaultStructOut=bStructOut;bVarOut=false;[bCleanedList] = false;if nargout<2	iType=1;	% (snelsnel bijgemaakte variabele)		% gemaakt om geven van warnings te verhinderen		%  iType=0 : error bij onbekende optie		%  iType=1 : warning bij ongekende optie		%  iType=2 : geen melding bij ongekende optieelse	iType=2;endoptsUsed = [];notUsed = cell(2,0);if isnumeric(varargin{1})	iType=varargin{1};	mogopt=varargin{2};	options=varargin(3:end);	if length(iType)>1		bStructOut=iType(2)==1;		bVarOut=iType(2)==2;		iType=iType(1);		if bVarOut			bStructOut=false;			bDefaultStructOut=false;		end	endelseif isstruct(varargin{1})	out=varargin{1};	mogopt=fieldnames(out);	options=varargin(2:end);	bDefaultStructOut=false;elseif isobject(varargin{1})	% same as isstruct?	out=varargin{1};	mogopt=fieldnames(out);	options=varargin(2:end);	bDefaultStructOut=false;	bStructOut = true;else	mogopt=varargin{1};	options=varargin(2:end);	if isempty(options)		return	% no options given	end	if isstruct(options{1})		bStructOut=true;		out=options{1};		bDefaultStructOut=false;		options(1)=[];	endendif bDefaultStructOut	v=version;	i=find(v=='.');	iv=str2num(v(1:i(min(end,2))-1)); %#ok<ST2NM>	if iv<6		out=[];	else		out=struct;	endendif isempty(options)	returnendif iscell(options{1})	if ~isscalar(options)		setoptions({'bCleanedList'},options{2:end})	end	options=options{1};	if min(size(options))==2&&size(options,2)==2&&(size(options,1)>2||~isstringlike(options{1,2}))		%the options are given as a list {nameopt1,valopt1;...}		options=options';	endelseif isscalar(options) && isstruct(options{1})	options = options{1};	C = fieldnames(options)';	for i=1:length(C)		C{2,i} = options.(C{1,i});	end	options = C;	% replace struct-options to cell arrayend% replace '-<option>' and '--<options>' by '<option>',true/false for%     early fault detection (before changing variable names)%     keep option-run-loop the same way it was done earlieri=1;while i<=numel(options)	option_i = options{i};	if isstring(option_i)		option_i = char(option_i);	end	if ~ischar(option_i)||isempty(option_i)		error('Wrong option list')	end	if size(options,1)>1		options=options(:)';	end	if option_i(1)=='-'		v=true;		if all(option_i=='-')			error('Bad "-"-format!')		end		option_i(1)=[];		if option_i(1)=='-'			if option_i(2)=='-'				v=-1;				option_i(1:2)=[];			else				v=false;				option_i(1)=[];			end		end		if isempty(option_i)			error('empty options?')		end		options=[options(1:i-1) {option_i,v} options(i+1:end)];	elseif option_i(1)=='?'		fprintf('Possible options:\n')		if isscalar(option_i)			printstr(mogopt)		else			V=cell(1,length(mogopt));			for j=1:length(mogopt)				v=evalin('caller',mogopt{j});				if ischar(v)&&size(v,1)==1&&~isempty(v)					if length(v)>30						v=[v(1:27) '...'];					end				elseif (isnumeric(v)||islogical(v))&&isscalar(v)&&imag(v)==0					if isnumeric(v)						v=sprintf('%g',v);					else						v=sprintf('logical %g',v);					end				else					s=size(v);					v=[sprintf('%s - %d',class(v),s(1)) sprintf('x%d',s(2:end))];				end				V{j}=v;			end			printstr('%s',mogopt,' def: %s',V)		end		options(i)=[];		i=i-2;	elseif any(option_i=='=')		b=option_i=='=';		if sum(b)>1			error('Error using option with multiple "="')		end		j=find(b);		if j==1			error('use of "=" in option as start??')		end		v=option_i(j+1:end);		vv=str2double(v);		if ~isnan(vv)			v=vv;		end		options=[options(1:i-1) {option_i(1:j-1) v} options(i+1:end)];	end	i=i+2;endif rem(numel(options),2)	error('A pair of options is needed')endif bCleanedList	out = options;	returnendoptions=reshape(options,2,[]);bOptUsed=true(1,size(options,2));options(3,:)=num2cell(zeros(1,length(bOptUsed)));for i=1:length(bOptUsed)	opt_i=options{1,i};	if ~isstringlike(opt_i)		error('Verkeerde options (options moeten paren van strings en data zijn')	end	if bStructOut&&i==1&&strcmpi(opt_i,'structbase')		out=options{2,i};	else		j=find(strncmpi(opt_i,mogopt,length(opt_i)));		j0=j;		bWarn=false;		if length(j)>1			j=find(strcmpi(opt_i,mogopt));			if length(j)~=1				j=find(strncmp(opt_i,mogopt,length(opt_i)));				if length(j)>1					j=find(strcmp(opt_i,mogopt));				end			end			if isempty(j)				warning('SETOPTIONS:unclearOption','het is onduidelijk wat met optie "%s" bedoeld wordt  - wordt genegeerd',opt_i)				fprintf('     (%s',mogopt{j0(1)});				fprintf(',%s',mogopt{j0(2:end)})				fprintf(')\n')				bWarn=true;			elseif length(j)>1				warning('SETOPTIONS:multiOptionPossible','optie "%s" heeft meerdere mogelijkheden - wordt genegeerd',opt_i)				bWarn=true;				j=[];			end		end		if isempty(j)			if ~bWarn&&iType<2				if iType<1					error('optie "%s" is ongekend',opt_i)				else					warning('SETOPTIONS:unknownOption','optie "%s" is ongekend',opt_i)				end			end			bOptUsed(i)=false;		else			options{1,i} = mogopt{j};	% adapt to correct name			if bStructOut				out.(mogopt{j})=options{2,i};			else				assignin('caller',mogopt{j},options{2,i});			end			options{3,i}=j;		end	endendif bStructOut && isa(out,'handle') && nargout==0	clear outelseif bVarOut	if nargout>length(mogopt)		error('Too many outputs!')	end	if nargout>4		varargout=cell(1,nargout-4);	end	for i=1:nargout		val=evalin('caller',mogopt{i});		switch i			case 1				out=val;			case 2				optsUsed=val;			case 3				options=val;			case 4				notUsed=val;			otherwise				varargout{i-4}=val;		end	endelseif nargout>1	optsUsed=bOptUsed;	if nargout>2		notUsed=options(:,~bOptUsed);	endend