function [X,D]=readpng(fnaam,bOnlyHDR,bOnlyMetadata)%readpng  - Reads a PNG graphics file%    [X,info]=readpng(fnaam,bOnlyHDR)%  (based on information on Wikipedia (26/5/2008)if ~exist('bOnlyHDR','var')||isempty(bOnlyHDR)	bOnlyHDR=false;endif ~exist('bOnlyMetadata','var')||isempty(bOnlyMetadata)	bOnlyMetadata=false;endcUpper=false(1,255);cUpper(abs('A'):abs('Z'))=true;if isstringlike(fnaam)	fid=fopen(fnaam);	if fid<3		error('Can''t open file.')	end	if bOnlyHDR		N=33;	else		N=Inf;	end	x=fread(fid,[1 N]);	fclose(fid);elseif isnumeric(fnaam)	x=fnaam;	if min(size(x))>1		error('A vector is expected!')	elseif isa(x,'uint8')		x=double(x);	elseif ~isa(x,'double')		warning('Unexpected input type (%s)! - processed as bytes',class(x))		x=double(x);	end	if size(x,1)>1		x=x';	endelse	error('Wrong input')endif length(x)<12	error('File was too short to be a PNG-file')endif any(x(1:8)~=[137 80 78 71 13 10 26 10])	error('Start of file is not correct to be a png-file')endbe=[16777216;65536;256;1];i=9;nX=0;iX=zeros(1000,2);D=struct('W',0,'H',0,'bitDepth',0,'colorType',0,'compMethod',0	...	,'filterMethod',0,'interlaceMethod',0,'X',[],'B0',[],'TPline',[]	...	,'unusedChunks',struct('type',cell(1,0),'data',[]));bEnd=false;nChunks=0;while i<length(x)-4	nChunks=nChunks+1;	if bEnd		warning('READPNG:dataAfterEnd','??data after end??')	end	lChunk=x(i:i+3)*be;	typChunk=char(x(i+4:i+7));	if any(typChunk<32|typChunk>127)		error('Impossible chunk type')	end	i0=i+8;	i1=i+7+lChunk;	%chunk=x(i+7:i+6+lChunk);	i=i+lChunk+12;	checksum=x(i-4:i-1)*be;	% check checksum - not done (yet)	xChunk=x(i0:i1);	switch typChunk	case 'IHDR'	% header		if nChunks>1			warning('READPNG:HeaderAfterData','??header after first data??')		end		head=xChunk;		D.W=head(1:4)*be;		D.H=head(5:8)*be;		D.bitDepth=head(9);		D.colorType=head(10);		D.compMethod=head(11);		D.filterMethod=head(12);		D.interlaceMethod=head(13);	case 'PLTE'	% palette		if rem(length(xChunk),3)==0			D.PLTE=reshape(xChunk,3,[])';		else			D.PLTE=xChunk;		end	case 'IDAT'	% data		nX=nX+1;		iX(nX,:)=[i0 i1];	case 'IEND'		bEnd=true;		%%%%%%%%%%%% anciallary chunks	case 'bKGD'	% backgroundcolor		D.bKGD=xChunk;	case 'cHRM'	% white balance		D.cHRM=xChunk;	case 'gAMA'	% gamma		D.gAMA=xChunk*be/100000;	case 'hIST'	% histogram		D.hIST=xChunk;	case 'iCCP'	% ICC color profile		D.iCCP=xChunk;	case 'iTXt'	% UT8 text, compressed or not, with an optional language tag		D.iTXt=xChunk;	case 'pHYs'	% physical reolution		D.pHYs=struct('xRes',xChunk(1:4)*be,'yRes',xChunk(5:8)*be,'unit',[]);		switch xChunk(9)			case 0				D.pHYs.unit='pix/[unknown]';			case 1				D.pHYs.unit='pix/m';			otherwise				D.pHYs.unit='not allowed!';		end	case 'sBIT'	% color-accuracy of source data		D.sBIT=xChunk;	case 'sPLT'	% suggests a palette to use if the full range of colors is unavailable		D.sPLT=xChunk;	case 'sRGB'	% indicates that the standard sRGB color space is used		D.sRGB=xChunk;	case 'tEXt'	% text in ISO 8859-1, with one name-value pair for each chunk		ii = [0 find(xChunk==0) length(xChunk)+1];		n = (length(ii)-1)/2;		if n>floor(n)			warning('no pairs found in tEXt-block!!')			S = xChunk;		else			S = struct();			for iS=1:n				Sname = char(xChunk(ii(iS*2-1)+1:ii(iS*2)-1));				Svalue = char(xChunk(ii(iS*2)+1:ii(iS*2+1)-1));	% convert from ISO 8859-1 to char?				S.(MakeVarNames(Sname)) = Svalue;			end		end		D.tEXt=S;	case 'tIME'	% time that the image was last changed		D.tIME=[256*x(i0)+x(i0+1) x(i0+2:i1)];	case 'tRNS'	% transparency information (indexed : alpha for palette entries, truecolor and grey : single pixel value color as fully transparent)		D.tRNS=xChunk;	case 'zTXt'	% contains compressed text with the same limits as tEXt		xChunk=uint8(xChunk);		iKeywEnd=find(xChunk==0,1);		if xChunk(iKeywEnd+1)==0	% standard inflate/deflate compression			bUncompressed=zuncompr(xChunk(iKeywEnd+2:end));		else			warning('Unknown type of compressed text!')		end		D.zTXt=struct('keyword',char(xChunk(1:iKeywEnd-1)),'txt',char(bUncompressed));	otherwise		if cUpper(abs(typChunk(1)))			warning('READPNG:UnknownCritChunk','!!unknown critical chunk of data neglected!! (%s)',typChunk)		end		D.unusedChunks(1,end+1).type=typChunk;		D.unusedChunks(end).data=xChunk;	endendnTot=sum(iX(1:nX,2)-iX(1:nX,1));X=zeros(1,nTot,'uint8');xi=0;for i=1:nX	nx1=iX(i,2)-iX(i)+1;	X(xi+1:xi+nx1)=uint8(x(iX(i):iX(i,2)));	xi=xi+nx1;endD.X=X;if isempty(X)||bOnlyMetadata	returnendif double(D.bitDepth)==8	% (matlab5.2 doesn't like calculations in uint8)	nBperPix=1;else	nBperPix=double(D.bitDepth)/8;	warning('READPNG:Not8bitData','!!currently only working on 8-bit data!!')	%returnendswitch double(D.colorType)	case 2		nBytesPerPix=3;	case 3		nBytesPerPix=1;	case 6		nBytesPerPix=4;	otherwise		warning('READPNG:otherColorType','!!currently only working with colorType6!! (this is %d)',D.colorType)		returnendlWidth=D.W*nBytesPerPix;nBytePerRow=ceil(lWidth*nBperPix)+1;b=zuncompr(X,nBytePerRow*D.H);B=reshape(b,nBytePerRow,D.H);D.TPline=B(1,:);D.B0=B(2:end,:);%B=int32(B);	% because of limiting with binary arithmetic(!)B=double(B);	% Matlab works faster in double precision!!% filteringLline=zeros(nBytePerRow-1+nBytesPerPix,1);	%,'int32');Nline=Lline;iB=2:nBytePerRow;iN=nBytesPerPix+1:length(Lline);for i=1:D.H	Nline(iN)=B(iB,i);	switch B(1,i)	case 0	% None		% no filtering	case 1	% Sub		for j=1:nBytesPerPix			Nline(j:nBytesPerPix:end)=cumsum(Nline(j:nBytesPerPix:end));		end		%for j=nBytesPerPix+1:length(Lline)		%	Nline(j)=Nline(j)+Nline(j-nBytesPerPix);		%end		Nline=bitand(Nline,255);	case 2	% Up		Nline=Nline+Lline;		Nline=bitand(Nline,255);	case 3 % Average		for j=nBytesPerPix+1:length(Lline)			%c=Nline(j)+bitshift(Nline(j-nBytesPerPix)+Lline(j),-1);			c=Nline(j)+floor((Nline(j-nBytesPerPix)+Lline(j))/2);			if c>255	% in place of bitand(c,255) - this is much faster				c=c-256;			end			Nline(j)=c;		end	case 4 % Paeth		for j=nBytesPerPix+1:length(Lline)			a=Nline(j-nBytesPerPix);			b=Lline(j);			c=Lline(j-nBytesPerPix);			p=a+b-c;			pa=abs(p-a);			pb=abs(p-b);			pc=abs(p-c);			if pa<=pb && pa<=pc				c=a;			elseif pb<=pc				c=b;			end			c=Nline(j)+c;			if c>255				c=c-256;			end			Nline(j)=c;%bitand(c,255); - bitand too slow		end	end	B(iB,i)=Nline(iN);	% (only if necessary, or directly in cases?)	Lline=Nline;endB=uint8(B);if nBytesPerPix>1	X=permute(reshape(B(2:end,:),nBytesPerPix,D.W,D.H),[3 2 1]);elseif nBytesPerPix==1	X=B(2:end,:)';	% (!!!color separation!!!)else	warning('READPNG:NotReadyBytesPerPix','!!!not ready!!!!')	X=B(2:end,:)';endif D.bitDepth==1	X1=X;	X=zeros(size(X1,1),8,size(X1,2),size(X1,3),'uint8');	b=1;	for i=1:8		X(:,9-i,:,:)=bitand(X1,b)>0;		b=b*2;	end	X=reshape(X,size(X1,1),[],size(X1,3));	if size(X,2)>D.W		X=X(:,1:D.W,:);	endend