function [D,TTTT]=fitsine(t,x,varargin)%fitsine  - Fit sine through a number of points%    D=fitsine(t,x[,options])%   Fits a sine wave through a signal from which it is expected to be close%   to a sine wave with a constant frequency.%   It is not necessary to have equidistant points.%  possible options : (pairs of option name and value)%    fSet    : fixed frequency%      the following options are only used if no given frequency%        and are used to do an estimate of the frequency%       fFilter : filter frequency (f<=0 ==> no filtering)%            second order high pass butter filtfilt is used%       bPerc   : interprete fLimH as "percentile" of all data,%           otherwise rLimH refers to relationship between min/max%       rLimH   : input for calculating high and low level part for%           searching for minima and maxima%   The calculation is done in two steps: "guessing" and "improving"%     The "guessing"-algorithm (calculating starting values) is done%     differently if the frequency is given or not.%     Frequency not given:%         - filter signal if requested%         - search for all local minima and maxima is done%             this is based on finding successive high values and%             successive low values;%             through all these extreme a 2nd order polynomial is fitted%             and the positions and values of the maxima are used as "tops"%             and "bottoms"%         - from these, the DC value, amplitude, time offset and frequency%             are estimated.%     Frequency is given: (kind of fourier data of on frequency is done)%         the DC component is calculated by calculating the mean value over%            a whole number of cycles.%         the DC component is subtracted from the signal to calculated the%            following%         by calculating the sum of the product of the signal with a sine%            and cosine of the given frequency over a full number of cycles,%         the phase and amplitude is calculated from this%     The estimated DC component, amplitude, time offset and if necessary%        frequency are updated successively by a cpu intensive, simple%        algorithm.  The error value (between the calculated sine and%        (unfiltered) signal is calculated for a couple of values.  A 2nd%        order polynomial is fitted, and the minimum value is used, if this%        is between estimated limits.% The function can also be used to calculate values using the%    fitsine-output:%        y=fitsine(D,t);%%  see also StonHann (much faster function without fitting with often%                     better results!!!)% also possible:%    fitsine warnings (or fitsine w)%        give warnings (default)%    fitsine nowarnings (or sitsine n)%        don't give warnings (some "real warnings" are still given)persistent doWarningsif isempty(doWarnings)	doWarnings=true;endoptions=varargin;if ischar(t)	if lower(t(1))=='w'		doWarnings=true;	elseif lower(t(1))=='n'		doWarnings=false;	else		error('wrong use of this function')	end	returnelseif isstruct(t)	D=cos((x-t.toffset)*(t.f*2*pi))*t.A+t.DC;	returnelseif min(size(t))>1	if nargin>1&&isnumeric(x)		error('Something is wrong with inputs')	end	if ~isempty(varargin)		options=[{x},varargin];	end	if size(t,1)<size(t,2)		t=t';	end	x=t(:,2);	t=t(:,1);endbPerc=false;	% percentile calculation for limits rather than just min/maxrLimH=0.8;fFilter=0;fSet=[];nLoop=4;rLimE=1e-8;bTest=nargout>1;[bMultiDimOptim]=false;	% as a test(!!) - not ready yet!!if ~isempty(options)	setoptions({'rLimH','bPerc','fFilter','fSet','nLoop','bTest'	...		,'rLimE','bMultiDimOptim'},options{:})enddf=0;nPts=length(t);dt=mean(diff(t));if ~isempty(fSet)	if fSet(1)>0	% given and fixed		% Check if given frequency can be right		f=fSet(1);		nCyc=(t(end)-t(1))*fSet(1);		if nCyc<1.1			warning('!!!low number of sine waves in measurement (%g)!!!',nCyc)			D=[];			return		end		nPts=round(floor(nCyc)/(f*dt));		if nPts<1			if doWarnings				warning('MLR:FITSINE:wrongFreqInput','Given frequency can''t be right for this data!')			end			fSet=-1;		else	% other checks?		end	end	if fSet(1)<=0	% fixed but not given (unless length(fSet)>1)		[f,df]=FFTestim(x,dt);		%fprintf('      fixed frequency : %g Hz\n',f)		nCyc=(t(end)-t(1))*f;		nPts=round(floor(nCyc)/(f*dt));		if length(fSet)>1			fSet(2)=df;		end	endendbAestimated=false;% Search for starting values for f, A, tOffset, DCif isempty(fSet)	if fFilter>0		if fFilter>1			if std(diff(t))/dt>1e-4				if doWarnings					warning('MLR:FITSINE:simpFilterNonEquiPts','Simple filtering used on non-equidistant data!!!')				end			end			rFilter=fFilter*dt;		else			rFilter=fFilter;		end		[Bf,Af]=butter(2,rFilter);		xf=filtfilt(Bf,Af,x);	else		xf=x;	end	bFirst=true;	while true		if bPerc			xs=sort(xf); %#ok<UNRCH>			Xh=xs(ceil(rLimH*length(xf)));			Xl=xs(ceil((1-rLimH)*length(xf)));			xmiddle=xs(ceil(length(xf)/2));		else			mx=max(xf);			mn=min(xf);			pkpk=mx-mn;			Xh=mn+pkpk*rLimH;			Xl=mn+pkpk*(1-rLimH);			xmiddle=(mx+mn)/2;		end		a=(xf(1)>=xmiddle)-1;		xST=zeros(size(xf));		xST(1)=a;		for i=2:length(xf)			if a>0				if xf(i)<=Xl					a=-1;				end			elseif xf(i)>=Xh				a=1;			end			xST(i)=a;		end		iCH=find(diff(xST));		E=zeros(length(iCH)-1,3);		E(:)=NaN;		if length(iCH)<4			iStart=1;	%????OK??			warning('MLR:FITSINE:lowNrCycles','!!!!low number of cycles!!!(??)!!')		else			iStart=2;		end		bNoisySigWarn=false;		bLowNptWarn=false;		bUnexpExtrWarn=false;		for i=iStart:length(iCH)-1 %(start from second (probably first whole cycle))			if iCH(i+1)-iCH(i)<4				if ~bNoisySigWarn					warning('MLR:FITSINE:NoisySignal','!!?noisy signal?')					bNoisySigWarn=true;				end			else				j=iCH(i)+1:iCH(i+1)-1;				if xST(j(1))>0					k=find(xf(j)>=Xh);				else					k=find(xf(j)<=Xl);				end				if length(k)<3					if ~bLowNptWarn						warning('MLR:FITSINE:LoNrPts','!!To low number of points!!!')						bLowNptWarn=true;					end				else					j=j(k(1)):j(k(end));					t1=t(j);					[p,~,Mu]=polyfit(t1,xf(j),2);					if p(1)*xST(j(1))>=0						if ~bUnexpExtrWarn							warning('MLR:FITSINE:UnexpExtremeProfile','!!unexpected extreme profile!!')							bUnexpExtrWarn=true;						end					else						tmx1=-p(2)/(2*p(1));						tmx=tmx1*Mu(2)+Mu(1);						if tmx<t1(1)||tmx>t1(end)							if doWarnings								warning('MLR:FITSINE:ToHighCorr','too high correction for extreme (%g s)!!',tmx)							end						else							E(i,1)=tmx;							Eex=polyval(p,tmx1);							E(i,(xST(j(1))<0)+2)=Eex;						end					end	% p(1)*xST(j(1)) OK				end	% length(k) OK			end		end %for i		iOK=find(~isnan(E(:,1)));		if length(iOK)<2||all(isnan(E(iOK,2)))||all(isnan(E(iOK,3)))			if bFirst				p=polyfit(t,xf,1);				xf=xf-p(1)*(t-mean(t));				bFirst=false;			elseif length(iOK)<2				warning('MLR:FITSINE:NotEnoughPtsFound','Not enough good points found')				iOK=[];				break			else				warning('MLR:FITSINE:NoMaxMinFound','No maximum or minimum could be determined!!')				iOK=[];				break			end		else			break		end	end % while true	if isempty(iOK)		f=FFTestim(x,dt);		df=f/10;		nCyc=(t(end)-t(1))*f;		if nCyc<1.1			warning('!!!low number of sine waves in measurement (%g)!!!',nCyc)			D=[];			return		end		nPts=round(floor(nCyc)/(f*dt));	else		dtOK=(E(iOK(2:end))-E(iOK(1:end-1)))./diff(iOK);		mnDif=(E(iOK(end))-E(iOK(1)))/(iOK(end)-iOK(1));		meanT=mean(dtOK);		if length(dtOK)>1			delT=max(std(dtOK),meanT/1e4);		else			delT=max(2*dt,meanT/50);	%!!!		end		if any((meanT-dtOK)/meanT>0.2)||delT/meanT>0.2			warning('MLR:FITSINE:HighChangeDT','too much changes in dt --- something went wrong in estimations - FFTestim is used')			[f,df]=FFTestim(x,dt);		else			f=0.5/mnDif;			df=f*(delT/mnDif/sqrt(iOK(end)-iOK(1)));		end		iMax=find(~isnan(E(:,2)));		iMin=find(~isnan(E(:,3)));		newMax=mean(E(iMax,2));		newMin=mean(E(iMin,3));		A=(newMax-newMin)/2;		if length(iMax)==1			dMax=A/3;		else			dMax=max(A/1e4,std(E(iMax,2)));		end		if length(iMin)==1			dMin=A/3;		else			dMin=max(A/1e4,std(E(iMin,3)));		end		dA=sqrt(dMin*dMin+dMax*dMax);	% worth doing this, rather than just adding min/max?		dA=max(dA,A/100);		DC=(newMax+newMin)/2;		T=(0:size(E,1)-1)'*mnDif;		offset=E(iOK)-T(iOK);		mnOffset=mean(offset);		if length(offset)>1			dOffset=max(mnDif/10,std(offset));	%%		else			dOffset=mnDif/10;		end		tOffset=mnOffset;		dDC=dA;		bAestimated=true;	endelse	if length(fSet)>1		df=fSet(2);		fSet=[];	endendif ~bAestimated	i=1:nPts;	DC=mean(x(i));	Zx=sum((x(i)-DC).*sin(f*2*pi*t(i)));	Zy=sum((x(i)-DC).*cos(f*2*pi*t(i)));	A=sqrt(Zx*Zx+Zy*Zy)/(length(i)/2);	phi=atan2(Zx,Zy);	tOffset=phi/(2*pi*f);	dA=A/10;	dDC=dA;	dOffset=0.1/f;	xf=x;	mnDif=[];meanT=[];delT=[];E=[];	%fprintf('%8.4f  %8.5f   ',A,phi)endy=cos((t-tOffset)*(f*2*pi))*A+DC;e0=sqrt(mean((x-y).^2));limE=A*rLimE;relList=-1.5:0.3:1.5;if bMultiDimOptim	D=MultiDimOptim(t,x,fSet,f,df,tOffset,dOffset,A,dA,DC,dDC,relList,nLoop);	returnendif bTest	if isempty(fSet)		TTT=struct('T','freq dt A DC','P',zeros(4,3)	...			,'Elijst',zeros(4,length(relList))	...			,'E',zeros(4,3));		i_F=1;i_dt=2;i_A=3;i_DC=4;	else		TTT=struct('T','dt A DC','P',zeros(3,3)	...			,'Elijst',zeros(3,length(relList))	...			,'E',zeros(3,3));		i_dt=1;i_A=2;i_DC=3;	endend% Do small corrections (in a too calculation intensive way)t0=mean(t);for iLoop=1:nLoop	if isempty(fSet)		fList=relList*df;		eLijst=fList;		for i=1:length(fList)			y1=cos((t-tOffset)*((f+fList(i))*2*pi)-2*pi*(t0-tOffset)*fList(i))*A+DC;			eLijst(i)=sum((x-y1).^2);		end		[p,~,Mu]=polyfit(fList,eLijst,2);		dfMin=-p(2)/(2*p(1))*Mu(2)+Mu(1);		if bTest			TTT.P(i_F,:)=p;			TTT.Elijst(i_F,:)=eLijst;			TTT.E(i_F,:)=[min(eLijst) f df];			subplot 221			plot(fList,[eLijst;polyval(p,(fList-Mu(1))/Mu(2))]');grid			line([0 0]+dfMin,[min(eLijst) max(eLijst)],'color',[1 0 0])			title freq			xlabel(sprintf('%10.3f - %10.3f (%10.3f)',f,dfMin,df))		end		if abs(dfMin)>fList(end);			if doWarnings				warning('MLR:FITSINE:dfToBit','f-offset was too big to be done (%g <--> %g Hz)!!',dfMin,df)			end			[~,i]=min(eLijst);			dfMin=fList(i);		else			df=df/3;		end		f1=f+dfMin;		tOffset1=tOffset+(t0-tOffset)*dfMin/f1;		y1=cos((t-tOffset1)*(f1*2*pi))*A+DC;		e01=sqrt(mean((x-y1).^2));		if e01>=e0			if abs(e0-e01)/e0>1e-4&&abs(dfMin)/df>0.2				if doWarnings					warning('MLR:FITSINE:noImp_f','!!no improvement!!')				end			end		else			f=f1;			tOffset=tOffset1;			e0=e01;			y(:)=y1;			if e0<limE				break;	% good enough!			end		end	end		dt=relList*dOffset;	eLijst=dt;	for i=1:length(dt)		y1=cos((t-tOffset+dt(i))*(f*2*pi))*A+DC;		eLijst(i)=sum((x-y1).^2);	end	[p,~,Mu]=polyfit(dt,eLijst,2);	dtMin=-p(2)/(2*p(1))*Mu(2)+Mu(1);	if bTest		TTT.P(i_dt,:)=p;		TTT.Elijst(i_dt,:)=eLijst;		TTT.E(i_dt,:)=[min(eLijst) tOffset dOffset];		subplot 222		plot(dt,[eLijst;polyval(p,(dt-Mu(1))/Mu(2))]');grid		title dt		line([0 0]+dtMin,[min(eLijst) max(eLijst)],'color',[1 0 0])		xlabel(sprintf('%10.6f - %10.6f (%10.6f)',tOffset,dtMin,dOffset))	end	if abs(dtMin)>dt(end);		if doWarnings			warning('MLR:FITSINE:DToffsetHigh','dt-offset was too big to be done (%g <--> %g s)!!',dtMin,dOffset)		end		[~,i]=min(eLijst);		dtMin=dt(i);	else		dOffset=dOffset/3;	end	y1=cos((t-tOffset+dtMin)*(f*2*pi))*A+DC;	e01=sqrt(mean((x-y1).^2));	if e01>=e0		if abs(e0-e01)/e0>1e-4&&e0>limE&&abs(dtMin)/dOffset>0.2			if doWarnings				warning('MLR:FITSINE:NoImprovementForToffset','!!no improvement!!')			end		end	else		tOffset=tOffset-dtMin;		e0=e01;		y(:)=y1;		if e0<limE			break;	% good enough!		end	end		DA=relList*dA;	eLijst=dA;	for i=1:length(DA)		y1=cos((t-tOffset)*(f*2*pi))*(A+DA(i))+DC;		eLijst(i)=sum((x-y1).^2);	end	[p,~,Mu]=polyfit(DA,eLijst,2);	dAMin=-p(2)/(2*p(1))*Mu(2)+Mu(1);	if bTest		TTT.P(i_A,:)=p;		TTT.Elijst(i_A,:)=eLijst;		TTT.E(i_A,:)=[min(eLijst) A dA];		subplot 223		plot(DA,[eLijst;polyval(p,(DA-Mu(1))/Mu(2))]');grid		title Amplitude		line([0 0]+dAMin,[min(eLijst) max(eLijst)],'color',[1 0 0])		xlabel(sprintf('%10.5f - %10.5f (%10.5f)',A,dAMin,dA))	end	if abs(dAMin)>DA(end);		if doWarnings			warning('MLR:FITSINE:AoffsetTooBig','A-offset was too big to be done (%g <--> %g)!!',dAMin,dA)		end		[~,i]=min(eLijst);		dAMin=DA(i);	else		dA=dA/3;	end	y1=cos((t-tOffset)*(f*2*pi))*(A+dAMin)+DC;	e01=sqrt(mean((x-y1).^2));	if e01>=e0		if abs(e0-e01)/e0>1e-4&&abs(dAMin)/dA>0.2			if doWarnings				warning('MLR:FITSINE:NoImprovementWithAcor','!!no improvement!!')			end		end	else		A=A+dAMin;		e0=e01;		y(:)=y1;		if e0<limE			break;	% good enough!		end	end		DClijst=relList*dDC;	eLijst=DClijst;	for i=1:length(DClijst)		y1=cos((t-tOffset)*(f*2*pi))*A+(DC+DClijst(i));		eLijst(i)=sum((x-y1).^2);	end	[p,~,Mu]=polyfit(DClijst,eLijst,2);	DCMin=-p(2)/(2*p(1))*Mu(2)+Mu(1);	if bTest		TTT.P(i_DC,:)=p;		TTT.Elijst(i_DC,:)=eLijst;		TTT.E(i_DC,:)=[min(eLijst) DC dDC];		TTT.E(:,1)=sqrt(TTT.E(:,1)/length(x));		printmat([TTT.P TTT.E]	...			,sprintf('iteration %d (%g)',iLoop,111)	...			,TTT.T,'p2 p1 p0 E V del')		subplot 224		plot(DClijst,[eLijst;polyval(p,(DClijst-Mu(1))/Mu(2))]');grid		title DCoffset		line([0 0]+DCMin,[min(eLijst) max(eLijst)],'color',[1 0 0])		xlabel(sprintf('%10.6f - %10.6f (%10.6f)',DC,DCMin,dDC))	end	if abs(DCMin)>DClijst(end);		if doWarnings			warning('MLR:FITSINE:DCoffetTooBig','DC-offset was too big to be done (%g <--> %g)!!',DCMin,dDC)		end		[~,i]=min(eLijst);		DCMin=DA(i);	else		dDC=dDC/3;	end	y1=cos((t-tOffset)*(f*2*pi))*A+(DC+DCMin);	e01=sqrt(mean((x-y1).^2));	if e01>=e0		if abs(e0-e01)/e0>1e-4&&abs(DCMin)/dDC>0.2			if doWarnings				warning('MLR:FITSINE:NoImprovementWithDC','!!no improvement!!')			end		end	else		DC=DC+DCMin;		e0=e01;		y(:)=y1;		if e0<limE			break;	% good enough!		end	end	if bTest&&nargout>1		if iLoop==1			TTTT=TTT(1,ones(1,nLoop));		else			TTTT(iLoop)=TTT;		end	end	%fprintf('     %8.4f  %8.5f',A,phi)end%fprintf('\n')phase=-tOffset*2*f*pi;if phase<0||phase>=2*pi	phase=phase-floor(phase/2/pi)*2*pi;endD=struct('t',t,'x',x,'xf',xf	...	,'A',A,'dA',dA,'P',mnDif,'P_est2',meanT,'dP',delT	...	,'f',f,'df',df	...	,'DC',DC,'dDC',dDC,'toffset',tOffset,'dtoffset',dOffset	...	,'phase',phase	...	,'E',E	...	,'y',y,'e',e0	...	);function [f,df]=FFTestim(x,dt)if size(x,1)==1	x=x(:);endN=65536;N4=N/4;Y=abs(fft((x-mean(x)).*hamming(length(x)),N));%Y=Y(1:N4);Y(1:ceil(N/length(x)*2.1)+1)=0;[~,i]=max(Y(1:N4));if i<2	f=1/dt/length(x);	df=f;else	%f=(i-1)/dt/N;	f=((i-2:i)*Y(i-1:i+1))/(sum(Y(i-1:i+1))*dt*N);	df=1/(dt*N*1.7);endfunction D=MultiDimOptim(t,x,fSet,f,df,tOffset,dOffset,A,dA,DC,dDC,relList,nLoop)% Do small corrections (in a too calculation intensive way)t0=mean(t);for iLoop=1:nLoop*0+1	if isempty(fSet)	% also optim f		fList=relList*df;	else		fList=f;	end	dtLijst=relList*dOffset;	DAlijst=relList*dA;	DClijst=relList*dDC;	[F,DT,DA,DCL]=ndgrid(f+fList,tOffset+dtLijst,A+DAlijst,DC+DClijst);	E=zeros(size(F));	for i=1:numel(E)		y1=cos((t-DT(i))*(F(i)*2*pi)-2*pi*(t0-tOffset)*(F(i)-f))*DA(i)+DCL(i);		E(i)=sum((x-y1).^2);	endendD=var2struct(fList,dtLijst,DAlijst,DClijst,E);