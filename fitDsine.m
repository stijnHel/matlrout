function D=fitDsine(t,x,varargin)%fitDsine  - Fit decreasing sine through a number of points%    D=fitDsine(t,x[,options])%   Fits a sine wave through a signal from which it is expected to be close%   to a sine wave with a constant frequency.%   It is not necessary to have equidistant points.%  possible options : (pairs of option name and value)%    fSet    : fixed frequency%      the following options are only used if no given frequency%        and are used to do an estimate of the frequency%       fFilter : filter frequency (f<=0 ==> no filtering)%            second order high pass butter filtfilt is used%       bPerc   : interprete fLimH as "percentile" of all data,%           otherwise rLimH refers to relationship between min/max%       rLimH   : input for calculating high and low level part for%           searching for minima and maxima%   The calculation is done in two steps: "guessing" and "improving"%     The "guessing"-algorithm (calculating starting values) is done%     differently if the frequency is given or not.%     Frequency not given:%         - filter signal if requested%         - search for all local minima and maxima is done%             this is based on finding successive high values and%             successive low values;%             through all these extreme a 2nd order polynomial is fitted%             and the positions and values of the maxima are used as "tops"%             and "bottoms"%         - from these, the DC value, amplitude, time offset and frequency%             are estimated.%     Frequency is given: (kind of fourier data of on frequency is done)%         the DC component is calculated by calculating the mean value over%            a whole number of cycles.%         the DC component is subtracted from the signal to calculated the%            following%         by calculating the sum of the product of the signal with a sine%            and cosine of the given frequency over a full number of cycles,%         the phase and amplitude is calculated from this%     The estimated DC component, amplitude, time offset and if necessary%        frequency are updated successively by a cpu intensive, simple%        algorithm.  The error value (between the calculated sine and%        (unfiltered) signal is calculated for a couple of values.  A 2nd%        order polynomial is fitted, and the minimum value is used, if this%        is between estimated limits.%%  this function can also be used to calculate the sine wave:%      y=fitsine(D,t);% also possible:%    fitDsine warnings (or fitDsine w)%        give warnings (default)%    fitDsine nowarnings (or sitsine n)%        don't give warnings (some "real warnings" are still given)persistent doWarningsif isempty(doWarnings)	doWarnings=true;endoptions=varargin;if ischar(t)	if lower(t(1))=='w'		doWarnings=true;	elseif lower(t(1))=='n'		doWarnings=false;	else		error('wrong use of this function')	end	returnelseif isstruct(t)  % calculate	if isfield(t,'tDec')		tDec=t.tDec;	else		tDec=0;	end	D=MakeSig(x,t.toffset,t.f,t.A,t.DC,tDec);	returnelseif min(size(t))>1	if nargin>1&&isnumeric(x)		error('Something is wrong with inputs')	end	if ~isempty(varargin)		options={x,varargin{:}};	end	if size(t,1)<size(t,2)		t=t';	end	x=t(:,2);	t=t(:,1);endbPerc=false;	% percentile calculation for limits rather than just min/maxrLimH=0.8;fFilter=0;fSet=[];nLoop=4;bTest=false;if ~isempty(options)	setoptions({'rLimH','bPerc','fFilter','fSet','nLoop','bTest'},options{:})enddf=0;meanDt=mean(diff(t));if ~isempty(fSet)	if fSet(1)>0	% given and fixed		% Check if given frequency can be right		f=fSet(1);		nCyc=(t(end)-t(1))*fSet(1);		if nCyc<1.1			error('!!!low number of sine waves in measurement (%g)!!!',nCyc)		end		nPts=round(floor(nCyc)/(f*meanDt));		if nPts<1			if doWarnings				warning('Given frequency can''t be right for this data!')			end			fSet=-1;		else	% other checks?		end	end	if fSet(1)<=0	% fixed but not given (unless length(fSet)>1)		[f,df]=FFTestim(x,meanDt);		%fprintf('      fixed frequency : %g Hz\n',f)		nCyc=(t(end)-t(1))*f;		nPts=round(floor(nCyc)/(f*meanDt));		if length(fSet)>1			fSet(2)=df;		end	endendbAestimated=false;% Search for starting values for f, A, tOffset, DCif isempty(fSet)	if fFilter>0		if fFilter>1			if std(diff(t))/meanDt>1e-4				if doWarnings					warning('Simple filtering used on non-equidistant data!!!')				end			end			rFilter=fFilter*meanDt;		else			rFilter=fFilter;		end		[Bf,Af]=butter(2,rFilter);		xf=filtfilt(Bf,Af,x);	else		xf=x;	end	bFirst=true;	while true		if bPerc			xs=sort(xf);			Xh=xs(ceil(rLimH*length(xf)));			Xl=xs(ceil((1-rLimH)*length(xf)));			xmiddle=xs(ceil(length(xf)/2));		else			mx=max(xf);			mn=min(xf);			pkpk=mx-mn;			Xh=mn+pkpk*rLimH;			Xl=mn+pkpk*(1-rLimH);			xmiddle=(mx+mn)/2;		end		a=(xf(1)>=xmiddle)-1;		xST=zeros(size(xf));		xST(1)=a;		for i=2:length(xf)			if a>0				if xf(i)<=Xl					a=-1;				end			elseif xf(i)>=Xh				a=1;			end			xST(i)=a;		end		iCH=find(diff(xST));		E=zeros(length(iCH)-1,3);		E(:)=NaN;		if length(iCH)<4			iStart=1;	%????OK??			warning('!!!!low number of cycles!!!(??)!!')		else			iStart=2;		end		for i=iStart:length(iCH)-1 %(start from second (probably first whole cycle))			j=iCH(i)+1:iCH(i+1)-1;			if xST(j(1))>0				k=find(xf(j)>=Xh);			else				k=find(xf(j)<=Xl);			end			if length(k)<3				warning('!!To low number of points!!!')			else				j=j(k(1)):j(k(end));				t1=t(j);				[p,S,Mu]=polyfit(t1,xf(j),2);				if p(1)*xST(j(1))>=0					warning('!!unexpected extreme profile!!')				else					tmx1=-p(2)/(2*p(1));					tmx=tmx1*Mu(2)+Mu(1);					if tmx<t1(1)|tmx>t1(end)						if doWarnings							warning('too high correction for extreme (%g s)!!',tmx)						end					else						E(i,1)=tmx;						Eex=polyval(p,tmx1);						E(i,(xST(j(1))<0)+2)=Eex;					end				end	% p(1)*xST(j(1)) OK			end	% length(k) OK		end %for i		iOK=find(~isnan(E(:,1)));		if length(iOK)<2||all(isnan(E(iOK,2)))|all(isnan(E(iOK,3)))			if bFirst				p=polyfit(t,xf,1);				xf=xf-p(1)*(t-mean(t));				bFirst=false;			elseif length(iOK)<2				warning('Not enough good points found')				iOK=[];				break			else				warning('No maximum or minimum could be determined!!')				iOK=[];				break			end		else			break		end	end	if isempty(iOK)		f=FFTestim(x,meanDt);		df=f/10;		nCyc=(t(end)-t(1))*f;		if nCyc<1.1			error('!!!low number of sine waves in measurement (%g)!!!',nCyc)		end		nPts=round(floor(nCyc)/(f*meanDt));	else		dtOK=(E(iOK(2:end))-E(iOK(1:end-1)))./diff(iOK);		mnDif=(E(iOK(end))-E(iOK(1)))/(iOK(end)-iOK(1));		meanT=mean(dtOK);		if length(dtOK)>1			delT=max(std(dtOK),meanT/1e4);		else			delT=max(2*meanDt,meanT/50);	%!!!		end		if (meanT-dtOK)/meanT>0.2|delT/meanT>0.2			error('too much changes in dt --- something went wrong in estimations')		end		f=0.5/mnDif;		df=f*(delT/mnDif/sqrt(iOK(end)-iOK(1)));		iMax=find(~isnan(E(:,2)));		iMin=find(~isnan(E(:,3)));		newMax=mean(E(iMax,2));		newMin=mean(E(iMin,3));		A=(newMax-newMin)/2;		if length(iMax)==1			dMax=A/3;		else			dMax=max(A/1e4,std(E(iMax,2)));		end		if length(iMin)==1			dMin=A/3;		else			dMin=max(A/1e4,std(E(iMin,3)));		end		dA=sqrt(dMin*dMin+dMax*dMax);	% worth doing this, rather than just adding min/max?		dA=max(dA,A/100);		DC=(newMax+newMin)/2;		T=(0:size(E,1)-1)'*mnDif;		offset=E(iOK)-T(iOK);		mnOffset=mean(offset);		if length(offset)>1			dOffset=max(mnDif/10,std(offset));	%%		else			dOffset=mnDif/10;		end		tOffset=mnOffset;		dDC=dA;		bAestimated=true;	endelse	if length(fSet)>1		df=fSet(2);		fSet=[];	endendif ~bAestimated	i=1:nPts;	DC=mean(x(i));	Zx=sum((x(i)-DC).*sin(f*2*pi*t(i)));	Zy=sum((x(i)-DC).*cos(f*2*pi*t(i)));	A=sqrt(Zx*Zx+Zy*Zy)/(length(i)/2);	phi=atan2(Zx,Zy);	tOffset=phi/(2*pi*f);	dA=A/10;	dDC=dA;	dOffset=0.1/f;	xf=x;	mnDif=[];meanT=[];delT=[];E=[];	%fprintf('%8.4f  %8.5f   ',A,phi)endtDec=0;dtDec=0;y=MakeSig(t,tOffset,f,A,DC,tDec);e0=sqrt(mean((x-y).^2));limE=A/1e8;e01=e0;relList=-1.5:0.3:1.5;if bTest	if isempty(fSet)		TTT=struct('T','freq dt A DC','P',zeros(4,3)	...			,'Elijst',zeros(4,length(relList))	...			,'E',zeros(4,3));		i_F=1;i_dt=2;i_A=3;i_DC=4;	else		TTT=struct('T','dt A DC','P',zeros(3,3)	...			,'Elijst',zeros(3,length(relList))	...			,'E',zeros(3,3));		i_dt=1;i_A=2;i_DC=3;	endend% Do small corrections (in a too calculation intensive way)for iLoop=1:nLoop	if isempty(fSet)		fList=relList*df;		eLijst=fList;		t0=mean(t);		for i=1:length(fList)			f1=f+fList(i);			dt1=tOffset+(t0-tOffset)*fList(i)/f1;			y1=MakeSig(t,dt1,f1,A,DC,tDec);			%y1=cos((t-tOffset)*((f+fList(i))*2*pi)-2*pi*(t0-tOffset)*fList(i))*A+DC;			eLijst(i)=sum((x-y1).^2);		end		[p,S,Mu]=polyfit(fList,eLijst,2);		dfMin=-p(2)/(2*p(1))*Mu(2)+Mu(1);		if bTest			TTT.P(i_F,:)=p;			TTT.Elijst(i_F,:)=eLijst;			TTT.E(i_F,:)=[min(eLijst) f df];			subplot 221			plot(fList,[eLijst;polyval(p,(fList-Mu(1))/Mu(2))]');grid			line([0 0]+dfMin,[min(eLijst) max(eLijst)],'color',[1 0 0])			title freq			xlabel(sprintf('%10.3f - %10.3f (%10.3f)',f,dfMin,df))		end		if abs(dfMin)>fList(end);			if doWarnings				warning('f-offset was too big to be done (%g <--> %g Hz)!!',dfMin,df)			end			[mn,i]=min(eLijst);			dfMin=fList(i);		else			df=df/3;		end		f1=f+dfMin;		tOffset1=tOffset+(t0-tOffset)*dfMin/f1;		%tOffset1=tOffset+(t0*dfMin+tOffset*f)/f1;				y1=MakeSig(t,tOffset1,f1,A,DC,tDec);		e01=sqrt(mean((x-y1).^2));		if e01>=e0			if abs(e0-e01)/e0>1e-4&&abs(dfMin)/df>0.2				if doWarnings					warning('!!no improvement!!')				end			end		else			f=f1;			tOffset=tOffset1;			e0=e01;			y(:)=y1;			if e0<limE				break;	% good enough!			end		end	end		dt=relList*dOffset;	eLijst=dt;	for i=1:length(dt)		y1=MakeSig(t,tOffset-dt(i),f,A,DC,tDec);		eLijst(i)=sum((x-y1).^2);	end	[p,S,Mu]=polyfit(dt,eLijst,2);	dtMin=-p(2)/(2*p(1))*Mu(2)+Mu(1);	if bTest		TTT.P(i_dt,:)=p;		TTT.Elijst(i_dt,:)=eLijst;		TTT.E(i_dt,:)=[min(eLijst) tOffset dOffset];		subplot 222		plot(dt,[eLijst;polyval(p,(dt-Mu(1))/Mu(2))]');grid		title dt		line([0 0]+dtMin,[min(eLijst) max(eLijst)],'color',[1 0 0])		xlabel(sprintf('%10.6f - %10.6f (%10.6f)',tOffset,dtMin,dOffset))	end	if abs(dtMin)>dt(end);		if doWarnings			warning('dt-offset was too big to be done (%g <--> %g s)!!',dtMin,dOffset)		end		[mn,i]=min(eLijst);		dtMin=dt(i);	else		dOffset=dOffset/3;	end	y1=MakeSig(t,tOffset-dtMin,f,A,DC,tDec);	e01=sqrt(mean((x-y1).^2));	if e01>=e0		if abs(e0-e01)/e0>1e-4&&e0>limE&&abs(dtMin)/dOffset>0.2			if doWarnings				warning('!!no improvement!!')			end		end	else		tOffset=tOffset-dtMin;		e0=e01;		y(:)=y1;		if e0<limE			break;	% good enough!		end	end		DA=relList*dA;	eLijst=dA;	for i=1:length(DA)		y1=MakeSig(t,tOffset,f,A+DA(i),DC,tDec);		eLijst(i)=sum((x-y1).^2);	end	[p,S,Mu]=polyfit(DA,eLijst,2);	dAMin=-p(2)/(2*p(1))*Mu(2)+Mu(1);	if bTest		TTT.P(i_A,:)=p;		TTT.Elijst(i_A,:)=eLijst;		TTT.E(i_A,:)=[min(eLijst) A dA];		subplot 223		plot(DA,[eLijst;polyval(p,(DA-Mu(1))/Mu(2))]');grid		title Amplitude		line([0 0]+dAMin,[min(eLijst) max(eLijst)],'color',[1 0 0])		xlabel(sprintf('%10.5f - %10.5f (%10.5f)',A,dAMin,dA))	end	if abs(dAMin)>DA(end);		if doWarnings			warning('A-offset was too big to be done (%g <--> %g)!!',dAMin,dA)		end		[mn,i]=min(eLijst);		dAMin=DA(i);	else		dA=dA/3;	end	y1=MakeSig(t,tOffset,f,A+dAMin,DC,tDec);	e01=sqrt(mean((x-y1).^2));	if e01>=e0		if abs(e0-e01)/e0>1e-4&&abs(dAMin)/dA>0.2			if doWarnings				warning('!!no improvement!!')			end		end	else		A=A+dAMin;		e0=e01;		y(:)=y1;		if e0<limE			break;	% good enough!		end	end		DClijst=relList*dDC;	eLijst=DClijst;	for i=1:length(DClijst)		y1=MakeSig(t,tOffset,f,A,DC+DClijst(i),tDec);		eLijst(i)=sum((x-y1).^2);	end	[p,S,Mu]=polyfit(DClijst,eLijst,2);	DCMin=-p(2)/(2*p(1))*Mu(2)+Mu(1);	if bTest		TTT.P(i_DC,:)=p;		TTT.Elijst(i_DC,:)=eLijst;		TTT.E(i_DC,:)=[min(eLijst) DC dDC];		TTT.E(:,1)=sqrt(TTT.E(:,1)/length(x));		printmat([TTT.P TTT.E]	...			,sprintf('iteration %d (%g)',iLoop,111)	...			,TTT.T,'p2 p1 p0 E V del')		subplot 224		plot(DClijst,[eLijst;polyval(p,(DClijst-Mu(1))/Mu(2))]');grid		title DCoffset		line([0 0]+DCMin,[min(eLijst) max(eLijst)],'color',[1 0 0])		xlabel(sprintf('%10.6f - %10.6f (%10.6f)',DC,DCMin,dDC))	end	if abs(DCMin)>DClijst(end);		if doWarnings			warning('DClijst-offset was too big to be done (%g <--> %g)!!',DCMin,dDC)		end		[mn,i]=min(eLijst);		DCMin=DA(i);	else		dDC=dDC/3;	end	y1=MakeSig(t,tOffset,f,A,DC+DCMin,tDec);	e01=sqrt(mean((x-y1).^2));	if e01>=e0		if abs(e0-e01)/e0>1e-4&&abs(DCMin)/dDC>0.2			if doWarnings				warning('!!no improvement!!')			end		end	else		DC=DC+DCMin;		e0=e01;		y(:)=y1;		if e0<limE			break;	% good enough!		end	end	if tDec<=0&&iLoop==1		n=floor(length(x)/2);		mx1=max(abs(x(1:n)-DC));		mx2=max(abs(x(end-n+1:end)-DC));		if mx2<mx1			tDec1=(t(end)-t(1))/2/log(mx1/mx2);			y1=MakeSig(t,tOffset,f,A,DC,tDec1);			A1=A*sum(abs(x-DC))/sum(abs(y1-DC));			y1=MakeSig(t,tOffset,f,A1,DC,tDec1);			e01=sqrt(mean((x-y1).^2));			if e01<e0				tDec=tDec1;				dtDec=tDec/5;	%!!!				A=A1;				y(:)=y1;				e0=e01;			end		end	end	if tDec>0		tDlist=relList*dtDec;		eLijst=tDlist;		for i=1:length(tDlist)			%???adapt A????			y1=MakeSig(t,tOffset,f,A,DC,tDec+tDlist(i));			eLijst(i)=sum((x-y1).^2);		end		[p,S,Mu]=polyfit(tDlist,eLijst,2);		tDmin=-p(2)/(2*p(1))*Mu(2)+Mu(1);		y1=MakeSig(t,tOffset,f,A,DC,tDec+tDmin);		e01=sqrt(mean((x-y1).^2));		if e01<e0			tDec=tDec+tDmin;			e0=e01;			y(:)=y1;			if e0<limE				break;	% good enough!			end		end		dtDec=dtDec/4;	end	%fprintf('     %8.4f  %8.5f',A,phi)end%fprintf('\n')phase=-tOffset*2*f*pi;D=struct('t',t,'x',x,'xf',xf	...	,'A',A,'dA',dA,'P',mnDif,'P_est2',meanT,'dP',delT	...	,'f',f,'df',df	...	,'DC',DC,'dDC',dDC,'toffset',tOffset,'dtoffset',dOffset	...	,'phase',phase	...	,'tDec',tDec,'dtDec',dtDec	...	,'E',E	...	,'y',y,'e0',e0,'e1',e01	...	);function [f,df]=FFTestim(x,dt)N=65536;N4=N/4;Y=abs(fft((x-mean(x)).*hamming(length(x)),N));Y=Y(1:N4);Y(1:ceil(N/length(x)*2.1)+1)=0;[mxY,i]=max(Y);%f=(i-1)/dt/N;f=((i-2:i)*Y(i-1:i+1))/(sum(Y(i-1:i+1))*dt*N);df=1/(dt*N*1.7);function y=MakeSig(t,tOffset,f,A,DC,tDec)if tDec>0	dA=exp((t(1)-t)/tDec);else	dA=1;endy=cos((t-tOffset)*(f*2*pi))*A.*dA+DC;