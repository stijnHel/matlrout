function [L,dX,dX0,Lunscaled]=runthroughgraph(X,pt,col,varargin)%runthroughgraph - Run though a bitmap-graph over a line%   [L,X]=runthroughgraph(X,pt,col)%      from a starting point, a line is followed on an image (made for graphs).%   L : [Xcoor Ycoor direction dir2 idxRestart width]%   X : binary image with true on dots of line (or a colour matching col)%     if X is not supplied, it is taken from an image in the current graph.%   X0: binary image before processing (so that dots of new line can be%       retrieved%% from the starting point the line is followed in different directions.%    at points where the line splits, different starting points are taken%% see also plotui% This function is used by plotui.  runthroughgraph uses - by default - the% scaling of the plotui-figure.%%%%!!!!!dit programma werkt niet goed (meer)!% * kan vast lopen als lijn tot einde figuur (?gebruik van sentinel/test%     op indices)% * loopt dikwijls fout bij aftakkingen, mogelijk door lijnen als:%                   pths(nPths,:)=[nL,x-dx,y-dy,id+nD2];%      pths(...,4) kan >4 worden% bij startpunt zou ook midden van lijn genomen moeten worden.bUIgraph=false;bUseHcolor=true;	% only active with multidimensional color spaceif ~exist('X','var')||isempty(X)	h=findobj(gca,'Type','image');	if length(h)~=1		error('Can''t find the image')	end	X=get(h,'cdata');	bUIgraph=true;endbScale=[];scale=[];bStructLine=true;options=varargin;if nargin>2	if ischar(col)		options=[{col},options];		col=[];	elseif iscell(col)		options=col;		col=[];	endelse	col=[];endbAll=false;if ~exist('pt','var')||isempty(pt)	if bUIgraph		pt=get(gca,'CurrentPoint');		pt=round(pt(1,1:2));	else		if isempty(col)			if ismatrix(X)				C=X;				b3D=false;			elseif isa(X,'uint8')&&size(X,3)==3				C=65536*uint32(X(:,:,1))+256*uint32(X(:,:,2))+uint32(X(:,:,3));				b3D=true;			else				error('Search for color is not found')			end			uC=unique(C(:));			if length(uC)~=2				if length(uC)<20					for i=1:length(uC)						fprintf('%06x: %d\n',uC(i),sum(C(:)==uC(i)))					end				end				error('Currently only two colours are allowed when automatic point and colour determination')			end			if sum(C(:)==uC(1))>sum(C(:)==uC(2))				col=uC(2);			else				col=uC(1);			end			if b3d				col=uint32([floor(col/65536) bitand(col,65280)/256 bitand(col,255)]);			end			bAll=true;		end	end	if max(X(:))>1&&isa(col,'double')&&max(col)<=1		col=col*255;	end	if ismatrix(X)		[i,j]=find(X==col);	else		[i,j]=find(X(:,:,1)==col(1)&X(:,:,2)==col(2)&X(:,:,3)==col(3),1);	end	if isempty(i)		error('No starting point found!')	end	pt=[j,i];endx=pt(1);y=pt(2);if ~isempty(options)	setoptions({'col','bAll','scale','bScale','bUseHcolor','bStructLine'}	...		,options{:})endif isempty(col)&&~isa(X,'logical')	col=squeeze(X(y,x,:));endif isempty(bScale)	if bUIgraph		s=getappdata(gcf,'schaal');		bScale=~isempty(s);	else		bScale=false;	endendif bAll	[L,dX,dX0]=runthroughgraph(X,pt,col);	LL={L};	n=size(L,1);	if islogical(bAll)||bAll>0		while any(dX(:))			[i,j]=find(dX,1);			[L,dX]=runthroughgraph(dX,[j,i],[]);			if ~isempty(L)				b=L(:,5)>0;				if any(b)					L(b,5)=L(b,5)+n;				end				L(1,5)=-1;				LL{1,end+1}=L;				n=n+size(L,1);			end		end	else		nDist=-bAll;		while true			% take surrounding of last calculated line			X=conv2(double(dX0&~dX),ones(nDist*2+1));			X=X(nDist+1:end-nDist,nDist+1:end-nDist);			B=X>0&dX;			[i,j]=find(B,1);			if isempty(i)				break			end			[L,dX,dX0]=runthroughgraph(dX,[j,i],[]);			if ~isempty(L)				b=L(:,5)>0;				if any(b)					L(b,5)=L(b,5)+n;				end				L(1,5)=-1;				LL{1,end+1}=L;				n=n+size(L,1);			end		end	end	L=cat(1,LL{:});	Lunscaled = L;	if bScale		L=scalePoints(L,scale);	end	returnendif isa(X,'logical')	dX=X;	[m,n]=size(X);else	tol=double(max(X(:)))/100;	% fixed color!	[m,n,nC]=size(X);	if nC>1		if bUseHcolor			% !!!!!volledig rood ([255 0 0]) == wit ([255 255 255])!!!			%       ===> andere kleuren toegevoegd			Xn=rgb2hsv(X);			if isa(X,'uint8')&&isa(col,'double')				col=uint8(col);			end			Chsv=rgb2hsv(reshape(col,1,1,3));			dX=abs(Xn(:,:,1)-Chsv(1))<.05	...				&abs(Xn(:,:,2)-Chsv(2))<.2	...				&abs(Xn(:,:,3)-Chsv(3))<.2;		else			dX=zeros(m,n); %#ok<UNRCH>			for i=1:nC				dX=dX+(double(X(:,:,i))-double(col(i))).^2;			end			dX=sqrt(dX)<=tol;		end	else		dX=abs(double(X)-double(col))<tol;	endendbWithSentinel=any(dX(1,:))|any(dX(end,:))|any(dX(:,1))|any(dX(:,end));if bWithSentinel	dX=[false(1,n+2);false(m,1),dX,false(m,1);false(1,n+2)];	% make sentinels	x=x+1;	y=y+1;end%dd=[1 0;1 1;0 1;-1 1];	% right, downright, down, leftdowndd=[1 0;0 1];	% right, downnD2=size(dd,1);dd=[dd;-dd];nD=size(dd,1);I=zeros(nD2,2);for i=1:nD	I(i)=findstartstop(dX,x,y,dd(i,1),dd(i,2));endw=sum(I,2);	% width in all directions (with opposite directions combined)[wmin,idw]=min(w);	% minimum width, and directionid=rem(idw,nD2)+1;	% orthogonal direction (supposed "walking direction")L=zeros(2*(m+n),6);	% memory for all points (with estimated maximum length - not for spirals!)nL=0;	% n points in listbAdd=true;	% add current point to list% take the middle of the line for the starting pointdx1=dd(idw,1);	% (dx1,dy1) opposite to walking directiondy1=dd(idw,2);i=round((I(idw,1)-I(idw,2))/2);x=x+dx1*i;	% take middle of widthy=y+dy1*i;% recalculate "widths" (with hopefully the same optimal direction...)for i=1:nD	I(i)=findstartstop(dX,x,y,dd(i,1),dd(i,2));endpths=[1 x y id+nD2];	% try first one direction, and store the other						% for later	% pths is "to do paths": [starting point, x, y, directionpths(100,1)=0;	% reserve memorynPths=1;	% number of pathsdX0=dX;	% store original for better with-determinationwhile true	% "walk" until no points (or elements in pths)	dx1=dd(idw,1);	% (dx1,dy1) opposite to walking direction	dy1=dd(idw,2);	dx=dd(id,1);	% (dx,dy) walking direction	dy=dd(id,2);	if bAdd		nL=nL+1;		if nL>size(L,1)			L(nL*2,1)=0;	% enlarge space		end		L(nL,1:4)=[x y id idw];		L(nL,6)=wmin;		% recalculate width in "available points"		I(idw,1)=findstartstop(dX,x,y,dd(idw  ,1),dd(idw,2));		I(idw,2)=findstartstop(dX,x,y,dd(idw+2,1),dd(idw+2,2));		dX(y,x)=false;	% mark points (opposite to walking direction)		for i=1:I(idw,1)			dX(y+dy1*i,x+dx1*i)=false;		end		for i=1:I(idw,2)			dX(y-dy1*i,x-dx1*i)=false;		end		i=round((I(idw,1)-I(idw,2))/2);		x=x+dx1*i;	% take middle of width		y=y+dy1*i;	else		bAdd=true;	end	% do one step (in "walking direction")	x=x+dx;	y=y+dy;	if dX(y,x)	% good point on new position		% OK - walk further	elseif dX(y+dy1,x+dx1)	% try opposite direction from new point (1)		if dX(y-dy1,x-dx1)	% split			nPths=nPths+1;			pths(nPths,:)=[nL,x-dx,y-dy,rem(id+nD2-1,nD)+1];		end		x=x+dx1;		y=y+dy1;	elseif dX(y-dy1,x-dx1)	% opposite direction (2)		x=x-dx1;		y=y-dy1;	elseif nPths>0	% paths to investigate?		iP=pths(nPths,1);		L(nL,5)=iP;		x=pths(nPths,2);		y=pths(nPths,3);		id=pths(nPths,4);		if id<1||id>4			error('something goed wrong2!!!!')		end		idw=rem(id,nD2)+1;		nPths=nPths-1;		bAdd=false;	else		break;	% all paths processed	end	if bAdd		% if point added look for line widths (in different directions)			% original (binary) image is used.		for i=1:nD			I(i)=findstartstop(dX0,x,y,dd(i,1),dd(i,2));		end		%I(rem(id+nD2-1,nD)+1)=wmin/2;	% because that part was cut off		w=sum(I,2);		[wmin,idwn]=min(w);		%if idwn~=idw&&w(idwn)==wmin		if idwn~=idw&&w(idw)==wmin			idwn=idw;		end		if idwn~=idw			idw=idwn;			id=rem(idw,nD2)+1;			nPths=nPths+1;			pths(nPths,:)=[nL,x,y,id+nD2];		end	endendL=L(1:nL,:);if bWithSentinel	L(:,1:2)=L(:,1:2)-1;	if nargout>1		dX=dX(2:m+1,2:n+1);		if nargout>2			dX0=dX0(2:m+1,2:n+1);		end	endendif bStructLine	[~,L]=structLine(L);endLunscaled = L;if bScale	L=scalePoints(L,scale);endfunction i=findstartstop(X,x,y,dx,dy)i=1;x=x+dx;y=y+dy;while X(y,x)	i=i+1;	x=x+dx;	y=y+dy;endi=i-1;function P=scalePoints(P,scale)if ~isempty(scale)	P(:,1:2)=plotui(scale,P(:,1:2));else	P(:,1:2)=plotui('convert',P(:,1:2));endfunction [D,L]=structLine(L)%structLine - tijdelijke functie ivm runthroughgraph%  structureert lijn, resultaat van runthroughgraph%        [D,L]=structLine(L)%% pogingen (deels gelukt) om te korte delen weg te halen%         en als er twee "hoofddelen" zijn, worden deze aan elkaar gehangen%% D wordt aangemaakt, maar niet gebruikt%   deze geeft: [idx0 k1 part1 part2 ...]%% L krijgt een licht andere structuur(!):%    input:  [X Y Dir oDir  S width]%            S:%    output: [X Y Dir witdh S']%            S':% nadeel:%     L krijgt licht andere betekenis dan voordien%      gevolg is dat combinatie van lijnen (met gebuik van structLine)%         niet meer door deze functie kunnen "opgekuist" worden.i=find(L(:,5)>0);	% restartsLi=L(i,5);	% idx origingslen_i=diff([i;size(L,1)+1]);ui=unique(Li);D=ui;D(1,4)=0;	% resize (reserve memory)% Search for blocks starting from the same pointfor j=1:length(ui)	k=find(Li==ui(j))';	k=[i(k)+1,len_i(k)]';	% [i1 l1;i2 l2;...]	D(j,3:2+numel(k))=k(:)';	k=find(L(ui(j):end,5));	if isempty(k)		k=size(L,1)+1-ui(j);	end	D(j,2)=k(1);end%  tweede poging naar "nuttig werk"% Determine paths from set of pointsiL0=size(L,2)+1;for i=1:size(L,1)-1	j=L(i,5);	if j==0	% continue path		k=iL0;		while k<=size(L,2)&&L(i,k)>0			k=k+1;		end		L(i,k)=i+1;	else	% new start		k=iL0;	% could be combine with previous(!)		while k<=size(L,2)&&L(j,k)>0			k=k+1;		end		L(j,k)=i+1;	endendif iL0>size(L,2)	% niets te doen?	if size(L,1)<3		L=zeros(0,5);	else		L(:,4)=[];	end	returnend% Determine lengths of pathslen=zeros(size(L,1),1)-1;nL=0;while nL<size(L,1)	for i=size(L,1):-1:1		len1=len(i);		if len1<0			if L(i,iL0)==0				len1=0;			else				k=L(i,iL0:end);				k(k==0)=[];				if all(len(k)>=0)					len1=1+max(len(k));				end			end		end	% if len1<0		if len1>=0			len(i)=len1;			nL=nL+1;		end	endendL=[L(:,1:iL0-1) len L(:,iL0:end)];iL0=iL0+1;% Remove "bad parts"for i=1:size(L,1)	k=nonzeros(L(i,iL0:end))';	if length(k)>1&&any(len(k)>0)		lk=len(k);		if any(lk>3)			limL=2;		elseif any(lk>1)			limL=1;		else			limL=0;		end		if any(lk<=limL)			k=k(lk>limL);			L(i,iL0:iL0+length(k)-1)=k;			L(i,iL0+length(k):end)=0;		end	endendL(:,5)=0;iL=zeros(1,size(L,1));iL(1)=1;nL=1;nxt=nonzeros(L(1,iL0:end));if iL0==size(L,2)	% voor de gemakkelijkheid straks	L(1,end+1)=0;endhoofdDelen=nxt;nxt(:,2)=1;iLast=1;while ~isempty(nxt)	nxt1=nxt(1);	L(iLast,5)=find(iL==nxt(1,2));	nxt(1,:)=[];	while nxt1>0		nL=nL+1;		iL(nL)=nxt1;		if L(nxt1,iL0+1)			nn=nonzeros(L(nxt1,iL0+1:end));			nn(:,2)=nxt1;			nxt=[nn;nxt];		end		iLast=nxt1;		nxt1=L(nxt1,iL0);	endendL=L(iL(1:nL),[1:3 6 5]);if length(hoofdDelen)==2	% keer 1 deel om	%%%? testen welke deel minst aantal splitsingen heeft?	i=find(L(:,5)==1);	i=i(2);	L(1:i,:)=L(i:-1:1,:);	L(1:i,3)=rem(L(1:i,3)+1,4)+1;	%(!!!)L(:,5) aanpassen!!!!end