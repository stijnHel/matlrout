function [Top,Tonder,E]=efemeride(D,el,pos,varargin)%EFEMERIDE - Bepaalt efemeriden van element%     [Top,Tonder,E]=efemeride(D,el,pos,opties)%		E : berekende posities :%          [T,opkomst of ondergang,P1,P2,Uur,Min,Sec]%!!!voor maan p0 vrij hoog gezet, er moet echter rekening gehouden worden met parallax%% Als het gaat om meerdere dagen, werkt deze functie ook voor andere% "elementen" (dan "zon"), maar niet ideaal!% Er is 1 datum voor op en onder, ervan uitgaande dat er eerst "op"% voorkomt en nadien "onder".  Bovendien is de periode ook niet 1 dag% voor andere elementen. Op zich wordt er niet uitgegaan van een periode% van 1 dag, maar als bijvoorbeeld de efemeride van elke dag voor een% "buitenplaneet" gevraagd wordt, is de periode niet 1 dag, en dit wordt% niet juist behandeld!!!!if ~exist('el','var')||isempty(el)	el='zon';endif ~exist('pos','var')||isempty(pos)	pos='ukkel';enddp0 = 0;[bCalcMinSec] = true;[bDateTime] = false;	% convert to datetime objects - in progress!!!!!d0 = [];	% starting date for "auto-fill"if ~isempty(varargin)	setoptions({'dp0','bCalcMinSec','bDateTime','d0'},varargin{:})endif bDateTime	bCalcMinSec = false;	% combination of the two is meaninglessendif ischar(pos)||min(size(pos))>1	pos=geogcoor(pos);endif isempty(d0)	d0=clock;elseif isscalar(d0)	d0=datevec(d0);elseif length(d0)==3	d0=d0(3:-1:1);else	error('Wrong input for d0')endif ~exist('D','var')	D=d0([3 2 1]);elseif size(D,2)>1||all(D(:)<1e5)	n=size(D,2);	if n<3		D(1,3)=0;		for i=n+1:3			D(:,i)=d0(4-i);		end	elseif n>6		error('Verkeerde input')	elseif n>3		D=D(:,1:3);	endendif size(D,1)>1	E=cell(1,size(D,1));	if size(D,2)>1		% it's allowed to give e.g. [100 1 2000], meaning day number 100 of		%   the year 2000.  To return the real dates this is converted		%   here.		T=datenum(D(:,[3 2 1]));		bContDates=all(diff(T)==1);		D=datevec(T);	% convert impossible dates to real dates		D=D(:,[3 2 1]);	else		bContDates=all(diff(D)==1);		D=GetDates(D);	end		status('Determination of efemerides',0)	nE=length(E);	if bContDates		% first do a couple of "independent searches", to continue with		% a faster method using previous data to predict "first guess".		nE1=min(3,length(E));	else		nE1=length(E);	end	for i=1:nE1		E{i}=efemeride(D(i,:),el,pos,'dp0',dp0,'bCalcMinSec',bCalcMinSec);		status(i/nE)	end	if nE1<nE		if all(cellfun('size',E(1:i),1)==2) % all with 1 rise and 1 set time			%Faster calculation of list of efemerides			T=cat(1,E{1:i});			Top=T(T(:,2)==1,:);			Tonder=T(T(:,2)==0,:);			Top(nE,1)=0;			Tonder(nE,1)=0;			Topi=Top(i);			Tonderi=Tonder(i);			dTop=Topi-Top(i-1);			dTonder=Tonderi-Tonder(i-1);			%d2Top=diff(Top(i-2:i),2);	% why not just 1:3?			%d2Tonder=diff(Tonder(i-2:i),2);			% The following can result in negative times or times higher			% than 24! (for the external planets)			% The calculation is kept like to avoid problems using			% differentials.  A consecquence is that the requested			% dates are not respected!			t=calcjd(D(i,:));			for i=i+1:nE				t=t+1;				p0=GetP0(t,el)+dp0;				%dTop=dTop+d2Top;				h1=Topi+dTop-.1;				p1=calcposhemel(pos,t+h1/24,el);				p1=p1(2)-p0;				h2=Topi+dTop+.1;				p2=calcposhemel(pos,t+h2/24,el);				p2=p2(2)-p0;				if p1*p2>0					error('This is not right!')				end				[h,p1,p2]=FindCrossing(pos,el,t,p0,h1,p1,h2,p2);				dTop=h-Topi;				Topi=h;				Top(i)=Topi;				Top(i,2)=1;				Top(i,3)=p1;				Top(i,4)=p2;				h1=Tonderi+dTonder-.1;				p1=calcposhemel(pos,t+h1/24,el);				p1=p1(2)-p0;				h2=Tonderi+dTonder+.1;				p2=calcposhemel(pos,t+h2/24,el);				p2=p2(2)-p0;				if p1*p2>0					error('This is not right!')				end				[h,p1,p2]=FindCrossing(pos,el,t,p0,h1,p1,h2,p2);				dTonder=h-Tonderi;				Tonderi=h;				Tonder(i)=Tonderi;				Tonder(i,2)=0;				Tonder(i,3)=p1;				Tonder(i,4)=p2;				status(i/nE)			end			status			bCorrDate = false;			B = Top(:,1)<0 | Top(:,1)>=24;			if any(B)				bCorrDate = true;				Dcor = datevec(datenum(D(B,[3 2 1]))+Top(B,1)/24);				Top(B,1) = mod(Top(B,1),24);				D(B,:) = Dcor(:,[3 2 1]);			end			B = Tonder(:,1)<0 | Tonder(:,1)>=24;			if any(B)				bCorrDate = true;				%Dcor = datevec(datenum(D(B,[3 2 1]))+Tonder(B,1)/24);					% only for Top !!! since there is only one D-array!!				Top(B,1) = mod(Tonder(B,1),24);				%D(B,:) = Dcor(:,[3 2 1]);			end			if bCorrDate				warning('Dates are corrected due to "day-crossing"!')			end			if bCalcMinSec				h=floor(Top(:,1));				mn=(Top(:,1)-h)*60;				Top(:,6)=floor(mn);				Top(:,7)=(mn-Top(:,6))*60;				Top(:,5)=h;				h=floor(Tonder(:,1));				mn=(Tonder(:,1)-h)*60;				Tonder(:,6)=floor(mn);				Tonder(:,7)=(mn-Tonder(:,6))*60;				Tonder(:,5)=h;			end			if nargout==1				% combine Top and Tonder				nCols = size(Top,2);				T=zeros(2,nE,nCols+3);				T(1,:,4:nCols+3)=Top;				T(2,:,4:nCols+3)=Tonder;				T(1,:,1:3)=D;				T(2,:,1:3)=D;				Top=reshape(T,nE*2,nCols+3);			end			return		else			for i=i+1:nE				E{i}=efemeride(D(i,:),el,pos,'dp0',dp0,'bCalcMinSec',bCalcMinSec);				status(i/nE)			end		end	end	status	if bDateTime		% do nothing	elseif nargout==0		T = datenum(D(:,[3 2 1]));		for i=1:nE			d=D(i,:);			fprintf('%2d/%02d/%4d: ',d)			bOp=E{i}(:,2)>0;			bOnder=E{i}(:,2)==0;			if sum(bOp)>1				fprintf('+')				ii=find(bOp);				bOp(ii(2:end))=false;			else				fprintf(' ')			end			if any(bOp)				t=E{i}(bOp,5:7);				fprintf('%2d:%02d:%04.1f',t)				bDST=isDST(T(i)+t*[1;1/60;1/3600]/24);				if bDST					fprintf('+')				else					fprintf(' ')				end			else				fprintf('%11c',' ')			end			if sum(bOnder)>1				fprintf('+')				ii=find(bOnder);				bOnder(ii(2:end))=false;			else				fprintf(' ')			end			if any(bOnder)				t=E{i}(bOnder,5:7);				fprintf('   %2d:%02d:%04.1f',t)				bDST=isDST(T(i)+t*[1;1/60;1/3600]/24);				if bDST					fprintf('+')				else					fprintf(' ')				end			else				fprintf('%11c',' ')			end			fprintf('\n')		end		% for i	else		for i=1:nE			E{i}=[D(i+zeros(1,size(E{i},1)),:) E{i}];		end		D=cat(1,E{:});		if nargout==1			Top=D;		else			if bCalcMinSec				ii=[1:3 8:10];			else				ii=1:4;			end			Top=D(D(:,5)>0,ii);			Tonder=D(D(:,5)==0,ii);		end	end		% if nargout - else	returnelseif size(D,2)==1	D=GetDates(D);end% zie verder chapter 55, hoewel er dan toch nog wat verkeerd lijkt te zijn.% bepalen van diameter zou beter in een aparte routine komen%???komt de fout doordat het centrum verder "naar onder" gaat, waardoor%  bijv. atmosferische aberratie overschat wordt?  Het gaat immers over%  dit top en niet het centrum waarvoor de correctie bepaald moet worden.switch elcase 'zon'	[~,~,d]=calcsc(D,0);	d=unitcon(d,'km','AU');	s=959.63/3600/180*pi/d;	%p0=-0.0039;	% ?in chap 15 staat 0�16' aangegeven? - 0.0047	p0=-s;	% testcase 'maan'	[~,~,d]=calclunarc(D);	% (geocentric radius is OK)	s=asin(0.272481*6378.14/d);	%p0=-0.0039;	%bepalen van grootte	p0=-s;otherwise	p0=0;endp0=p0+dp0;t0=calcjd(D(1:3));h2=0;p1=calcposhemel(pos,t0,el);p1=p1(2)-p0;if  p1==0	error('Dit is een ongelofelijk toeval... of er liep iets fout.')endif bCalcMinSec	E=zeros(2,7);else	E=zeros(2,3);endnE=0;while h2<24	h1=h2;	h2=h1+1;	p2=calcposhemel(pos,t0+h2/24,el);	p2=p2(2)-p0;	if p1*p2<=0		nE=nE+1;		E(nE,2)=p2>p1;		[h,p1,p2]=FindCrossing(pos,el,t0,p0,h1,p1,h2,p2);		E(nE,1)=h;		E(nE,3)=p1;		E(nE,4)=p2;	end	p1=p2;endif nE<size(E,1)	E=E(1:nE,:);endif bCalcMinSec	h=floor(E(:,1));	mn=(E(:,1)-h)*60;	E(:,6)=floor(mn);	E(:,7)=(mn-E(:,6))*60;	E(:,5)=h;endif bDateTime	Top = datetime(D([3 2 1]))+hours(E(:,1)');	if nargout>1		Tonder = Top(E(:,2)==0);		Top = Top(E(:,2)>0);	endelseif nargout==1	Top=E;elseif nargout>1	if bCalcMinSec		Top=E(E(:,2)>0,5:7);		Tonder=E(E(:,2)==0,5:7);	else		Top=E(E(:,2)>0,1);		Tonder=E(E(:,2)==0,1);	endelseif bCalcMinSec	fprintf('%2d:%02d:%04.1f\n',E(:,5:7)')else	fprintf('%7.4f ',E(:,1))	fprintf('\n')endfunction D=GetDates(D)if all(D<1e6)	D=datevec(D);	D=D(:,[3 2 1]);else	D=calccaldate(D);	D=D(:,1:3);endfunction [h,p1,p2]=FindCrossing(pos,el,t,p0,h1,p1,h2,p2)n=0;lrep=0;f=-p1/(p2-p1);h=h1+f*(h2-h1);while min(abs([p1 p2]))>=1e-8	n=n+1;	if n>100		break;	end	p=calcposhemel(pos,t+h/24,el);	p=p(2)-p0;	fCor=0;	if p*p1>=0		h1=h;		p1=p;		if f<0.02&&lrep==1			fCor=2;		end		lrep=1;	else		h2=h;		p2=p;		if f>0.98&&lrep==2			fCor=-2;		end		lrep=2;	end	f=-p1/(p2-p1);	if fCor>0		f=f*2;	elseif fCor<0		f=1-(1-f)*2;	end	h=h1+f*(h2-h1);end%pT=calcposhemel(pos,t+h/24,el);%pT=pT(2)-p0;%printmat([n p1 p2 p pT])function p0=GetP0(D,el)% zie verder chapter 55, hoewel er dan toch nog wat verkeerd lijkt te zijn.% bepalen van diameter zou beter in een aparte routine komen%???komt de fout doordat het centrum verder "naar onder" gaat, waardoor%  bijv. atmosferische aberratie overschat wordt?  Het gaat immers over%  dit top en niet het centrum waarvoor de correctie bepaald moet worden.switch elcase 'zon'	[~,~,d]=calcsc(D,0);	d=unitcon(d,'km','AU');	s=959.63/3600/180*pi/d;	%p0=-0.0039;	% ?in chap 15 staat 0�16' aangegeven? - 0.0047	p0=-s;	% testcase 'maan'	[~,~,d]=calclunarc(D);	% (geocentric radius is OK)	s=asin(0.272481*6378.14/d);	%p0=-0.0039;	%bepalen van grootte	p0=-s;otherwise	p0=0;end